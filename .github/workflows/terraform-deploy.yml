name: Terraform Deploy

on:
  push:
    branches:
      - develop
    paths:
      - "infra/**"
      - ".github/workflows/terraform-deploy.yml"
  workflow_dispatch:
    inputs:
      force_apply:
        description: "Force apply even if no infra changes"
        required: false
        default: false
        type: boolean

env:
  PROJECT_ID: dataanalyticsclinic
  REGION: asia-northeast1
  TERRAFORM_STATE_BUCKET: dataanalyticsclinic-terraform-state
  # Lock staleness threshold in seconds (30 minutes)
  LOCK_STALE_THRESHOLD: 1800
  # Maximum retry attempts
  MAX_RETRIES: 3
  # Delay between retries (seconds) - uses exponential backoff
  RETRY_BASE_DELAY: 10

jobs:
  terraform:
    name: Terraform Apply
    runs-on: ubuntu-latest
    concurrency:
      group: terraform-deploy
      cancel-in-progress: false
    permissions:
      contents: read
      id-token: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - id: "auth"
        name: "Authenticate to Google Cloud"
        uses: "google-github-actions/auth@v2"
        with:
          workload_identity_provider: "${{ secrets.WIF_PROVIDER }}"
          service_account: "${{ secrets.WIF_SERVICE_ACCOUNT }}"

      - name: "Set up Cloud SDK"
        uses: "google-github-actions/setup-gcloud@v2"

      - name: "Set up Terraform"
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.6.0

      - name: "Configure gcloud"
        run: |
          gcloud config set project ${{ env.PROJECT_ID }}
          gcloud config set compute/region ${{ env.REGION }}

      - name: "Check and Remove Stale Lock"
        run: |
          LOCK_FILE="gs://${{ env.TERRAFORM_STATE_BUCKET }}/terraform/dev/state/default.tflock"
          echo "Checking for stale lock file..."

          # Check if lock file exists
          if gsutil ls "$LOCK_FILE" 2>/dev/null; then
            echo "Lock file found. Checking if it's stale..."

            # Get lock file metadata and extract creation time
            LOCK_METADATA=$(gsutil stat "$LOCK_FILE" 2>/dev/null || echo "")

            if [ -n "$LOCK_METADATA" ]; then
              # Extract creation time from metadata
              CREATION_TIME=$(echo "$LOCK_METADATA" | grep "Creation time:" | sed 's/.*Creation time:[[:space:]]*//')

              if [ -n "$CREATION_TIME" ]; then
                # Convert creation time to epoch seconds
                LOCK_EPOCH=$(date -d "$CREATION_TIME" +%s 2>/dev/null || echo "")
                CURRENT_EPOCH=$(date +%s)

                if [ -n "$LOCK_EPOCH" ]; then
                  LOCK_AGE=$((CURRENT_EPOCH - LOCK_EPOCH))
                  echo "Lock age: ${LOCK_AGE} seconds (threshold: ${{ env.LOCK_STALE_THRESHOLD }})"

                  if [ "$LOCK_AGE" -gt "${{ env.LOCK_STALE_THRESHOLD }}" ]; then
                    echo "Lock is stale (older than 30 minutes). Removing..."
                    gsutil rm "$LOCK_FILE" 2>/dev/null && echo "Stale lock removed" || echo "Could not remove lock"
                  else
                    echo "Lock is not stale (less than 30 minutes old). Waiting for it to be released..."
                  fi
                else
                  echo "Could not parse lock creation time. Skipping lock removal for safety."
                fi
              else
                echo "Could not extract creation time. Skipping lock removal for safety."
              fi
            fi
          else
            echo "No lock file found. Proceeding..."
          fi

      - name: "Terraform Init"
        working-directory: infra/envs/dev
        run: |
          terraform init \
            -backend-config="bucket=${{ env.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="prefix=terraform/dev/state"

      - name: "Terraform Plan with Retry"
        id: plan
        working-directory: infra/envs/dev
        run: |
          # Reusable retry function with exponential backoff
          terraform_with_retry() {
            local command="$1"
            local max_retries="${{ env.MAX_RETRIES }}"
            local base_delay="${{ env.RETRY_BASE_DELAY }}"
            local retry_count=0

            while [ $retry_count -lt $max_retries ]; do
              echo "Executing: terraform $command (Attempt $((retry_count + 1))/$max_retries)"

              if eval "terraform $command"; then
                echo "Terraform $command succeeded"
                return 0
              else
                retry_count=$((retry_count + 1))

                if [ $retry_count -lt $max_retries ]; then
                  # Exponential backoff: base_delay * 2^(retry_count-1)
                  delay=$((base_delay * (1 << (retry_count - 1))))
                  echo "Terraform $command failed. Retrying in ${delay} seconds... (Attempt $retry_count/$max_retries)"
                  sleep "$delay"
                else
                  echo "Terraform $command failed after $max_retries attempts"
                  return 1
                fi
              fi
            done
          }

          # Run terraform plan with lock timeout (safer than manual lock removal)
          terraform_with_retry "plan -lock-timeout=5m -out=tfplan"

      - name: "Terraform Apply with Fresh Plan"
        working-directory: infra/envs/dev
        run: |
          # Retry function with exponential backoff and conditional plan regeneration
          # Only regenerates plan when error indicates staleness
          terraform_apply_with_retry() {
            local max_retries="${{ env.MAX_RETRIES }}"
            local base_delay="${{ env.RETRY_BASE_DELAY }}"
            local retry_count=0

            while [ $retry_count -lt $max_retries ]; do
              echo "Executing: terraform apply (Attempt $((retry_count + 1))/$max_retries)"

              # Capture both stdout and stderr for error analysis
              local output
              local exit_code
              output=$(terraform apply -lock-timeout=5m -auto-approve tfplan 2>&1) && exit_code=0 || exit_code=$?

              echo "$output"

              if [ $exit_code -eq 0 ]; then
                echo "Terraform apply succeeded"
                return 0
              fi

              retry_count=$((retry_count + 1))

              if [ $retry_count -lt $max_retries ]; then
                # Exponential backoff: base_delay * 2^(retry_count-1)
                local delay=$((base_delay * (1 << (retry_count - 1))))
                echo "Terraform apply failed (exit code: $exit_code). Retrying in ${delay} seconds... (Attempt $retry_count/$max_retries)"
                sleep "$delay"

                # Only regenerate plan if error indicates staleness
                if echo "$output" | grep -qE "(Saved plan is stale|state was changed by another operation)"; then
                  echo "Detected stale plan error. Regenerating plan..."
                  if ! terraform plan -lock-timeout=5m -out=tfplan; then
                    echo "Failed to regenerate plan"
                    return 1
                  fi
                  echo "Plan regenerated successfully"
                else
                  echo "Error is not related to stale plan. Retrying with existing plan..."
                fi
              else
                echo "Terraform apply failed after $max_retries attempts"
                return 1
              fi
            done
          }

          # Run terraform apply with retry logic
          terraform_apply_with_retry

      - name: "Verify Cloud Run Service"
        working-directory: infra/envs/dev
        run: |
          # Cloud Runサービスの一覧を表示（検証用）
          echo "=== Cloud Run Services ==="
          gcloud run services list \
            --region=${{ env.REGION }} \
            --project=${{ env.PROJECT_ID }} \
            --format="table(SERVICE,REGION,URL)"

          # Terraformの出力からサービスURIを取得（オプション）
          echo ""
          echo "=== Terraform Outputs ==="
          terraform output cloud_run 2>/dev/null || echo "Output not available"
